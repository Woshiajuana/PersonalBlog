
# React

> [中文官网](https://react.docschina.org/)

用于构建用户界面的 `JavaScript` 库。

特点：
- 声明式的设计；
- 采用虚拟 `DOM` + 优秀的 `Diffing` 算法，尽量减少与真实 `DOM` 的交互；
- 灵活，跟其他库可灵活搭配使用；
- 使用 `JSX`；
- 组件化、模块化，代码容易复用。
- 单向数据流。没有实现数据的双向绑定。数据 => 视图 => 事件 => 数据；

## React 的基本使用

### 相关 js 库

- `react.js` ：`React` 核心库；
- `react-dom.js` ：提供操作 `DOM` 的扩展库 `ReactDOM` ；
- `babel.min.js` ：解析 `JSX` 语法代码转为 `JS` 代码库；
- `prop-types.js` ：用于对组件标签属性进行限制；

### 虚拟 DOM

关于虚拟 DOM
- 本质就是 `Object` 类型的对象（一般对象）；
- 虚拟 `DOM` 比较"轻"，真实 `DOM`比较"重"，虚拟 `DOM` 是 `React` 内部在用，无需真实 `DOM` 上那么多属性；
- 虚拟 `DOM` 最终会被 `React` 转成真实 `DOM`，呈现在页面上；

创建虚拟 `DOM` 的两种方式
1. 使用 `JSX` 语法；
```
// 1. 创建虚拟 `DOM`；
const VDOM = <h1 id="title">Hello World</h1>;
// 2. 渲染虚拟 `DOM` 到页面；
ReactDOM.render(VDOM, document.getElementById('root'));
```
2. 使用 `React.createElement(标签名, 属性, 内容)`
```
// 1. 创建虚拟 `DOM`；
const VDOM = React.createElement('h1', { id: 'title' }, 'Hello World');
// 2. 渲染虚拟 `DOM` 到页面；
ReactDOM.render(VDOM, document.getElementById('root'));
```


## React JSX

- 全称 `JavaScript XML`；
- `react` 定义的一种类似于 `XML` 的 `JS` 扩展语法：`JS + XML`；
- 本质是 `React.createElement(component, props, ...children)` 方法的语法糖；
- 用来简化创建虚拟 `DOM`
    + 写法 `let ele = <h1>Hello JSX!</h1>`；
    + 就是一个 `JS` 对象，最终会被渲染成真实的 `DOM`； 
- 标签名任何。

`JSX` 语法规则
- 定义虚拟 `DOM` 时，不要写引号；
- `JSX` 元素对象或者组件对象，必须只有一个根元素节点；
- 标签首字母
    + 如果是小写开头，则将该标签转为 `html` 中同名元素，若 `html` 中无该标签对应的同名元素，则报错；
    + 如果大写字母开头，`react` 就去渲染对应的组件，若组件没有定义，则报错。
- 标签中混入 `JS`  表达式时要用 `{}`；
    + 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方；
- 样式的类名指定不要用 `class`，要用 `className`（`class` 在 `js` 语法中是一个关键字）；
- 内联样式 `style` 要用 `style={{key: value}}` 的形式去写；


函数式组件开发
```
// react 函数式组件
function Clock(props) {
    return (
        <div>
            <h1>现在的时间是{props.date.toLocaleTimeString()}</h1>
            <h2>这是副标题</h2>
        </div>
    )
}
```

JSX Style 样式

```
let exampleStyle = {
    background: 'blue',
    borderBottom: '1px solid red',
    'background-image': '',
};
let arrClassName = ['bg', 'fontsize'];
let element = (
    <div>
        <h1 className={arrClassName.join(' ')} style={exampleStyle}>hello world</h1>
    </div>
);
ReactDOM.render(
    element,
    document.getElementById('root'),
);
```

注释写法
```
let element = (
    <div>
        {/*这里写注释*/}
        <h1 className={arrClassName.join(' ')} style={exampleStyle}>hello world</h1>
    </div>
);
```


## React 开发者工具调试

`React Developer Toos`



 
## React 脚手架创建项目

步骤
1. 安装脚手架 `create-react-app`；
```
npm install -g create-react-app
```
2. 创建项目；
```
create-react-app <project-directory>
```
3. 启动
```
npm run start
```
4. 打包部署
```
npm run build
```


## React 组件

分为函数式组件和类组件，区别：
- 函数式比较简单，一般用于静态没有交互事件的内容；
- 类组件一般又称为动态组件，会有交互或者数据修改的操作；

### 函数式组件

```
function HelloWorld (props) {
    console.log(this); // 此处的 this 是 undefined，因为 babel 编译后开启了严格模式
    return (
        <div>
            <h1>hello world</h1>
        </div>
    );
}
ReactDOM.render(
    <HelloWorld />,
    document.getElementById('root'),
);
```

执行流程
- `React` 解析组件标签，找到了 `HelloWorld` 组件；
- 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟 `DOM` 转为真实的 `DOM`，随后呈现在页面中；



### 类组件

```
class HelloWorld extends React.Component {
    render() {
        console.log(this.props);
        return (
            <div>
                <h1>hello world</h1>
            </div>
        );
    }
}
ReactDOM.render(
    <HelloWorld />,
    document.getElementById('root'),
);
```

执行流程
- `React` 解析组件标签，找到了 `HelloWorld` 组件；
- 发现组件是使用类定义的，随后new 出来该类的实例，并且通过该实例调用到原型上的 `render` 方法；
- 将 `render` 返回的虚拟 `DOM` 转为真实的 `DOM`，随后呈现在页面中；



## React 生命周期事件

- 绑定事件命名为驼峰命名法；
- 传入一个函数，而不是字符串；

**注意** `React` 返回的事件对象是代理的原生的事件对象，如果想要
查看事件对象具体属性，需要直接输出该属性；

组件从实例化到最终从页面中销毁的这整个过程就是生命周期。
在这个过程当中，有许多生命周期钩子函数。

生命周期的三个状态
- `Mounting` ： 将组件插入到 `DOM` 中；
- `Updating` ： 将数据更新到 `DOM` 中；
- `Unmounting` ： 将组件移除 `DOM` 中；

生命周期中的钩子函数（方法、事件）
- `componentWillMount` 组件将要挂载渲染
- `componentDidMount` 组件渲染完毕
- `componentWillReceiveProps` 组件将要接收 `props` 数据
- `shouldComponentUpdate` 组件接收到新的 `state` 或者 `props` ，判断是否更新，返回布尔值
- `componentWillUpdate` 组件将要更新
- `componentDidUpdate` 组件已经更新
- `componentWillUnmount` 组件将要卸载

```
class Lifecycle extends React.Component {
    constructor (props) {
        super(props);
    }
    // 组件将要挂载渲染
    componentWillMount() {

    }
    // 组件渲染完毕
    componentDidMount() {

    }
    // 组件将要接收 props 数据
    componentWillReceiveProps(nextProps, nextContext) {

    }
    // 组件接收到新的 state 或者 props ，判断是否更新，返回布尔值
    shouldComponentUpdate(nextProps, nextState, nextContext) {

    }
    // 组件将要更新
    componentWillUpdate(nextProps, nextState, nextContext) {

    }
    // 组件已经更新
    componentDidUpdate(prevProps, prevState, snapshot) {

    }
    // 组件将要卸载
    componentWillUnmount(){

    }
    // 渲染
    render () {
        return null
    }
}
```

## React State 状态

- `state` 是组件对象最重要的属性，值是对象（可以包含多个 `key-value` 的组合）；
- 组件被称为 "状态机" ，通过更新组件的 `state` 来更新对应的页面显示（重新渲染组件）；


```
class Clock extends React.Component {
    constructor (props) {
        super(props);
        // 构造函数初始化数据
        this.state = {
            time: new Date().toLocaleTimeString(),
        }
    }
    render() {
        return (
            <div>
                <p>当前时间：{this.state.time}</p>
            </div>
        );
    }
    // 生命周期函数，组件渲染完成的函数
    componentDidMount() {
        setInterval(() => {
            // 设置状态修改数据
            this.setState({
                time: new Date().toLocaleTimeString(),
            });
            // 注意此时 this.state.time 值不一定会是修改之后的值
            // react 会在设置完状态后，对比虚拟 DOM 对象，然后再统一修改，提升性能
            console.log(this.state.time);  
        }, 1000);
    }
}
```

**注意**
- 组件中 `render` 方法中的 `this` 为组件实例对象；
- 组件自定义的方法中 `this` 为 `undefined` ，如何解决？
    + 强制绑定 `this`，通过函数对象的 `bind()` 方法；
    + 箭头函数
- 状态数据不能直接修改或更新，需要使用 `setState()` 方法；



## React Props 

- 父组件传给子组件的数据，单向流动，不能子组件传递给父组件；
- 可以是任意类型的值，可以是函数，所以可以通过函数去修改父组件的状态；
- 可以设置默认值；

```
class ParentComponent extends React.Component {
    constructor (props) {
        super (props);
        this.state = {
            text: '',
        }
    }
    onText (e) {
        this.setState({ text: e });
    }
    render () {
        return (
            <div>
                <p>从子组件接收到的参数：{this.state.text}</p>
                <ChildComponent onText={ (e) => this.onText(e) } />
            </div>
        )
    }
}
class ChildComponent extends React.Component {
    constructor (props) {
        super (props);
    }
    onClick () {
        this.props.onText('hello world');
    }
    render () {
        return (
            <div>
                <button onClick={ () => this.onClick() }>给父组件传递参数</button>
            </div>
        )
    }
}
```

属性类型、必要性、默认值限制
```
class Person extends React.Component{}

// 类型限制
Person.propTypes = {
    name: PropTypes.string.isRequired,
    sex: PropTypes.string,
    speak: PropTypes.func, // 限制是函数
}

// 默认值
Person.defaultProps = {
    sex: '男',
}
```


## React 条件渲染

- `if...else...`；
- 三元运算符；

```
class TabSwitch extends React.Component {
    constructor (props) {
        super(props);
        this.state = {
            index: 0,
        }
    }
    onClick (index) {
        this.setState({ index });
    }
    render () {
        return (
            <div>
                <div>
                    <button onClick={() => this.onClick(0)}>按钮1</button>
                    <button onClick={() => this.onClick(1)}>按钮2</button>
                </div>
                {
                    this.state.index === 0 ? <div>内容1</div> : <div>内容2</div>
                }
            </div>
        );
    }
}
```

## React 列表渲染

```
class ListComponent extends React.Component {
    constructor (props) {
        super(props);
        this.state = {
            arr: [ 'a', 'b', 'c', 'd' ]
        }
    }
    render () {
        return (
            <ul>{this.state.arr.map((item, index) => <li key={index}>{item}</li>)}</ul>
        );
    }
}
```

## React 插槽

组件中写入内容，这些内容可以被识别和控制；

```
class SlotComponent extends React.Component {
    constructor (props) {
        super(props);
    }
    render () {
        return (
            <div>
                <h1>组件内容</h1>
                {this.props.children[0]}
                {this.props.children[1]}
                {this.props.children[2]}
            </div>
        );
    }
}
ReactDOM.render(
    <SlotComponent>
        <p>子组件1</p>
        <p>子组件2</p>
        <p>子组件3</p>
    </SlotComponent>,
    document.getElementById('root'),
);
```

## React 路由

根据不同的路径，显示不同的组件内容，`React` 使用的库 `react-router-dom`。

```
npm install react-router-dom --save
```

ReactRouter 三大组件
- `Router` ：所有路由组件的根组件（底层组件），包裹路由规则的最外层容器；
    + `basename` 属性：基础路径；
- `Route` ：路由规则匹配组件，显示当前规则对应的组件；
    + `exact` 属性：精确匹配；
- `Link` ：路由跳转的组件；
    + `replace` 属性：点击链接后，讲新地址替换成历史访问记录的源地址；
- `Redirect` 重定向组件，重定向路由组件：如果访问某个组件时，有重定向组件，那么就会修改页面的路径，使得
页面内容显示为所重定向路径的内容。
- `Switch` 组件，只匹配一个 `route` 内容；

**注意**如果要精确匹配，那么可以在 `route` 上设置 `exact` 属性。


路由模式
- `hash` 模式
```
import { HashRouter as Router, Link, Route } from 'react-router-dom'
```
- `history` 模式
```
import { BrowserRouter as Router, Link, Route } from 'react-router-dom'
```

```
function Home() {
    return (
        <h1>我是首页内容</h1>
    );
}
function List() {
    return (
        <h1>我是列表内容</h1>
    );
}__
function Details() {
    return (
        <h1>我是详情内容</h1>
    );
}
class RouterComponent extends React.Component {
    constructor (props) {
        super(props);
    }
    render () {
        return (
            <Router>
                <nav>
                    <Link to='/'>首页</Link>
                    <Link to='/list'>列表页</Link>
                    <Link to='/details'>详情页</Link>
                </nav>
                <Route path='/' exact component={Home}/>
                <Route path='/list' exact component={List}/>
                <Route path='/details' exact component={Details}/>
            </Router>
        );
    }
}
```

props
- `history`：可以用来操作路由；
- `location`：路由信息；
- `match`：处理后的数据；


## Redux

```
npm install redux --save
```

解决 `React` 数据管理（状态管理），用于中大型，数据比较庞大，组件之间
数据交互多的情况下使用。
- 解决组件的数据通信；
- 解决数据和交互较多的应用；
- `Store` ：数据仓库，保存数据的地方；
- `State` ：数据仓库里的所有数据都放到1个 `state` 里；
- `Action` ：一个动作，触发数据改变的方法；
- `Dispatch` ：将动作触发成方法；
- `Reducer` ：一个函数，改变数据，生成一个新的 `state`，从而改变页面；

简单使用
```
import { createStore } from 'redux'
const reducer = function(state = { num: 0 }, action) {
    switch (action.type) {
        case 'add':
            state.num++;
            break;
        case 'decrement':
            state.num--;
            break;
        default:
            break;
    }
    return state;
};
// 创建仓库
const store = createStore(reducer);
class CountNumberComponent extends React.Component {
    render () {
        return (
            <div>
                <h1>当前数值：{store.getState().num}</h1>
                <div>
                    <button onClick={() => store.dispatch({ type: 'add' })}>+1</button>
                    <button onClick={() => store.dispatch({ type: 'decrement' })}>-1</button>
                </div>
            </div>
        )
    }
}
store.subscribe(() => {
    ReactDOM.render(
        <CountNumberComponent/>,
        document.getElementById('root'),
    );
});
```


## React-Redux

```
npm install react-redux --save
```

```
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import { createStore } from 'redux'
import { Provider, connect } from 'react-redux'

const reducer = function(state = { num: 0 }, action) {
    switch (action.type) {
        case 'add':
            state.num++;
            break;
        case 'decrement':
            state.num--;
            break;
        default:
            break;
    }
    return {...state};
};
const store = createStore(reducer);
class CountNumberComponent extends React.Component {
    render () {
        console.log(this.props);
        return (
            <div>
                <h1>当前数值：{this.props.num}</h1>
                <div>
                    <button onClick={this.props.add}>+1</button>
                    <button onClick={this.props.decrement}>-1</button>
                </div>
            </div>
        )
    }
}
const App = connect(
    (state) => ({
        num: state.num,
    }),
    (dispatch) => ({
        add: () => dispatch({ type: 'add' }),
        decrement: () => dispatch({ type: 'decrement' }),
    }),
)(CountNumberComponent);
ReactDOM.render(
    <Provider store={store}>
        <App/>
    </Provider>,
    document.getElementById('root'),
);
```
