
# React

> [中文官网](https://react.docschina.org/)

用于构建用户界面的 `JavaScript` 库。

特点：
- 声明式的设计；
- 高效，采用虚拟 `DOM` 来实现 `DOM` 的渲染，最大限度的减少 `DOM` 的操作；
- 灵活，跟其他库可灵活搭配使用；
- 使用 `JSX`；
- 组件化、模块化，代码容易复用。
- 单向数据流。没有实现数据的双向绑定。数据 => 视图 => 事件 => 数据；


## React 脚手架创建项目

步骤
1. 安装脚手架 `create-react-app`；
```
npm install -g create-react-app
```
2. 创建项目；
```
create-react-app <project-directory>
```
3. 启动
```
npm run start
```
4. 打包部署
```
npm run build
```

## React JSX

使用 `JSX` 的写法，可以创建 `JS` 元素对象
```
const h1 = <h1>helloworld</h1>;
```

**注意**
- `JSX` 元素对象或者组件对象，必须只有一个根元素节点；
- 正常的普通 `HTML` 元素要小写。如果是大写，默认认为是组件；

函数式组件开发
```
// react 函数式组件
function Clock(props) {
    return (
        <div>
            <h1>现在的时间是{props.date.toLocaleTimeString()}</h1>
            <h2>这是副标题</h2>
        </div>
    )
}
```

JSX Style 样式

```
let exampleStyle = {
    background: 'blue',
    borderBottom: '1px solid red',
    'background-image': '',
};
let arrClassName = ['bg', 'fontsize'];
let element = (
    <div>
        <h1 className={arrClassName.join(' ')} style={exampleStyle}>hello world</h1>
    </div>
);
ReactDOM.render(
    element,
    document.getElementById('root'),
);
```

注释写法
```
let element = (
    <div>
        {/*这里写注释*/}
        <h1 className={arrClassName.join(' ')} style={exampleStyle}>hello world</h1>
    </div>
);
```

## React 组件

分为函数式组件和类组件，区别：
- 函数式比较简单，一般用于静态没有交互事件的内容；
- 类组件一般又称为动态组件，会有交互或者数据修改的操作；

### 函数式组件

创建
```
function HelloWorld (props) {
    return (
        <div>
            <h1>hello world</h1>
        </div>
    );
}
```

使用
```
ReactDOM.render(
    <HelloWorld />,
    document.getElementById('root'),
);
```


### 类组件

创建
```
class HelloWorld extends React.Component {
    render() {
        console.log(this.props);
        return (
            <div>
                <h1>hello world</h1>
            </div>
        );
    }
}
```

使用
```
ReactDOM.render(
    <HelloWorld />,
    document.getElementById('root'),
);
```

## React 生命周期事件

- 绑定事件命名为驼峰命名法；
- 传入一个函数，而不是字符串；

**注意** `React` 返回的事件对象是代理的原生的事件对象，如果想要
查看事件对象具体属性，需要直接输出该属性；

组件从实例化到最终从页面中销毁的这整个过程就是生命周期。
在这个过程当中，有许多生命周期钩子函数。

生命周期的三个状态
- `Mounting` ： 将组件插入到 `DOM` 中；
- `Updating` ： 将数据更新到 `DOM` 中；
- `Unmounting` ： 将组件移除 `DOM` 中；

生命周期中的钩子函数（方法、事件）
- `componentWillMount` 组件将要挂载渲染
- `componentDidMount` 组件渲染完毕
- `componentWillReceiveProps` 组件将要接收 `props` 数据
- `shouldComponentUpdate` 组件接收到新的 `state` 或者 `props` ，判断是否更新，返回布尔值
- `componentWillUpdate` 组件将要更新
- `componentDidUpdate` 组件已经更新
- `componentWillUnmount` 组件将要卸载

```
class Lifecycle extends React.Component {
    constructor (props) {
        super(props);
    }
    // 组件将要挂载渲染
    componentWillMount() {

    }
    // 组件渲染完毕
    componentDidMount() {

    }
    // 组件将要接收 props 数据
    componentWillReceiveProps(nextProps, nextContext) {

    }
    // 组件接收到新的 state 或者 props ，判断是否更新，返回布尔值
    shouldComponentUpdate(nextProps, nextState, nextContext) {

    }
    // 组件将要更新
    componentWillUpdate(nextProps, nextState, nextContext) {

    }
    // 组件已经更新
    componentDidUpdate(prevProps, prevState, snapshot) {

    }
    // 组件将要卸载
    componentWillUnmount(){

    }
    // 渲染
    render () {
        return null
    }
}
```

## React State 状态

```
class Clock extends React.Component {
    constructor (props) {
        super(props);
        // 构造函数初始化数据
        this.state = {
            time: new Date().toLocaleTimeString(),
        }
    }
    render() {
        return (
            <div>
                <p>当前时间：{this.state.time}</p>
            </div>
        );
    }
    // 生命周期函数，组件渲染完成的函数
    componentDidMount() {
        setInterval(() => {
            // 设置状态修改数据
            this.setState({
                time: new Date().toLocaleTimeString(),
            });
            // 注意此时 this.state.time 值不一定会是修改之后的值
            // react 会在设置完状态后，对比虚拟 DOM 对象，然后再统一修改，提升性能
            console.log(this.state.time);  
        }, 1000);
    }
}
```

## React Props 

- 父组件传给子组件的数据，单向流动，不能子组件传递给父组件；
- 可以是任意类型的值，可以是函数，所以可以通过函数去修改父组件的状态；
- 可以设置默认值；

```
class ParentComponent extends React.Component {
    constructor (props) {
        super (props);
        this.state = {
            text: '',
        }
    }
    onText (e) {
        this.setState({ text: e });
    }
    render () {
        return (
            <div>
                <p>从子组件接收到的参数：{this.state.text}</p>
                <ChildComponent onText={ (e) => this.onText(e) } />
            </div>
        )
    }
}
class ChildComponent extends React.Component {
    constructor (props) {
        super (props);
    }
    onClick () {
        this.props.onText('hello world');
    }
    render () {
        return (
            <div>
                <button onClick={ () => this.onClick() }>给父组件传递参数</button>
            </div>
        )
    }
}
```

## React 条件渲染

- `if...else...`；
- 三元运算符；

```
class TabSwitch extends React.Component {
    constructor (props) {
        super(props);
        this.state = {
            index: 0,
        }
    }
    onClick (index) {
        this.setState({ index });
    }
    render () {
        return (
            <div>
                <div>
                    <button onClick={() => this.onClick(0)}>按钮1</button>
                    <button onClick={() => this.onClick(1)}>按钮2</button>
                </div>
                {
                    this.state.index === 0 ? <div>内容1</div> : <div>内容2</div>
                }
            </div>
        );
    }
}
```

## React 列表渲染

```
class ListComponent extends React.Component {
    constructor (props) {
        super(props);
        this.state = {
            arr: [ 'a', 'b', 'c', 'd' ]
        }
    }
    render () {
        return (
            <ul>{this.state.arr.map((item, index) => <li key={index}>{item}</li>)}</ul>
        );
    }
}
```

## React 插槽

组件中写入内容，这些内容可以被识别和控制；

```
class SlotComponent extends React.Component {
    constructor (props) {
        super(props);
    }
    render () {
        return (
            <div>
                <h1>组件内容</h1>
                {this.props.children[0]}
                {this.props.children[1]}
                {this.props.children[2]}
            </div>
        );
    }
}
ReactDOM.render(
    <SlotComponent>
        <p>子组件1</p>
        <p>子组件2</p>
        <p>子组件3</p>
    </SlotComponent>,
    document.getElementById('root'),
);
```

## React 路由

根据不同的路径，显示不同的组件内容，`React` 使用的库 `react-router-dom`。

```
npm install react-router-dom --save
```

ReactRouter 三大组件
- `Router` ：所有路由组件的根组件（底层组件），包裹路由规则的最外层容器；
    + `basename` 属性：基础路径；
- `Route` ：路由规则匹配组件，显示当前规则对应的组件；
    + `exact` 属性：精确匹配；
- `Link` ：路由跳转的组件；
    + `replace` 属性：点击链接后，讲新地址替换成历史访问记录的源地址；
- `Redirect` 重定向组件，重定向路由组件：如果访问某个组件时，有重定向组件，那么就会修改页面的路径，使得
页面内容显示为所重定向路径的内容。
- `Switch` 组件，只匹配一个 `route` 内容；

**注意**如果要精确匹配，那么可以在 `route` 上设置 `exact` 属性。


路由模式
- `hash` 模式
```
import { HashRouter as Router, Link, Route } from 'react-router-dom'
```
- `history` 模式
```
import { BrowserRouter as Router, Link, Route } from 'react-router-dom'
```

```
function Home() {
    return (
        <h1>我是首页内容</h1>
    );
}
function List() {
    return (
        <h1>我是列表内容</h1>
    );
}__
function Details() {
    return (
        <h1>我是详情内容</h1>
    );
}
class RouterComponent extends React.Component {
    constructor (props) {
        super(props);
    }
    render () {
        return (
            <Router>
                <nav>
                    <Link to='/'>首页</Link>
                    <Link to='/list'>列表页</Link>
                    <Link to='/details'>详情页</Link>
                </nav>
                <Route path='/' exact component={Home}/>
                <Route path='/list' exact component={List}/>
                <Route path='/details' exact component={Details}/>
            </Router>
        );
    }
}
```

props
- `history`：可以用来操作路由；
- `location`：路由信息；
- `match`：处理后的数据；


## React Redux

```
npm install redux --save
```

解决 `React` 数据管理（状态管理），用于中大型，数据比较庞大，组件之间
数据交互多的情况下使用。
- 解决组件的数据通信；
- 解决数据和交互较多的应用；
- `Store` ：数据仓库，保存数据的地方；
- `State` ：数据仓库里的所有数据都放到1个 `state` 里；
- `Action` ：一个动作，触发数据改变的方法；
- `Dispatch` ：将动作触发成方法；
- `Reducer` ：一个函数，改变数据，生成一个新的 `state`，从而改变页面；
