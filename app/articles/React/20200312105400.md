
# 深入理解 React


## Virtual DOM 的理解

- 优点：
    + 处理了浏览器的兼容性问题，避免用户操作真实 DOM；
    + 内容进过了 XSS 处理，可以防范 XSS 攻击；
    + 容易实现跨平台开发 Android、iOS、VR 应用；
    + 更新的时候可以实现差异化更新，减少更新 DOM 的操作；
- 缺点：
    + 虚拟 DOM 需要消耗额外的内存；
    + 首次渲染其实并不一定会更快；



## 函数组件和类组件的相同点和不同点

- 相同点
    + 都可以接收属性并返回 React 元素；
- 不同点
    + 编程思想不同：类组件需要创建实例，是基于面向对象的方式编程。而函数式组件不需要创建实例，接收输入，返回输出，是基于
函数式编程的思想写的；
    + 内存占用：类组件需要创建并保存实例，会占用一定内存，函数组件不需要创建实例，可以节约内存占用；
    + 捕获特性：函数组件具有值捕获的特性；
    + 可测试性：函数式组件更方便编写单元测试；
    + 状态：类组件有自己的实例，可以定义状态，而且可以修改状态更新组件，函数式组件以前没有状态，现在可以使用 `useState` 使用状态；
    + 生命周期：类组件有自己完整的生命周期，可以在生命周期内编写逻辑，函数组件以前没有生命周期，现在可以使用 `useEffect` 实现类似生命周期的逻辑；
    + 逻辑复用：类组件可以通过继承实现逻辑复用，但是官方推荐组件优于继承，函数组件可以通过自定义 `Hooks` 实现逻辑的复用；
    + 跳过更新：类组件可以通过 `shouldComponentUpdate` 和 `PureComponent` 来跳过更新，而函数式组件可以使用 `React.momo` 来跳过更新；
    + 发展前景：函数组件会成为主流，它可以更好的屏蔽 `this` 问题、规范和复用逻辑、更好的适合时间分片和并发渲染；



## React 中的渲染流程

- 设计理念；
    + 跨平台渲染、虚拟 DOM；
    + 快速响应、异步可以中断 + 增量更新；
- 性能瓶颈；
    + 浏览器的刷新频率为60Hz，大概是16.6毫秒会渲染一次，而 JS 线程和渲染线程是互斥的，所以如果 JS 线程执行任务的时间超过
16.6毫秒的话，就会导致掉帧，从而出现卡顿。解决的方案就是 React 利用空闲的时间进行更新，不影响渲染进行的；
    + 把一个耗时任务切分成一个个小任务，分布在每一帧里面的方式就叫时间切片；
- `requestIdleCallback`，`chrome` 支持；
    + 它使开发者能在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应；
    + 正常帧任务完成后没超过16毫秒，说明时间有富余，此时会执行 `requestIdleCallback` 里面注册的任务；
- `react` 为了兼容性，使用了 `MessageChannel` + `requestAnimationFrame` 模拟了一个 `requestIdleCallback`；
- 写法：
```
// 同步
ReactDOM.render(<App/>, document.getElementById('root'));
// 异步可中断
ReactDOM.unstable_createRoot(document.getElementById('root')).render(<App/>); // 实验版本才会有这个 api
```
- **注** `react` 为了兼容这种异步操作，所以把 `componentWillMount` 、 `componentWillUpdate` 、 `componentWillReceiveProps` 废弃掉了；
- `fiber` 
    + 是一个执行单元；
        * 每次执行完一个执行单元，`React` 就会检查现在还剩多少时间，如果没有时间就将控制权让出去；
        * ![流程图](images/WX20210514-105509.png)
    + 是一种数据结构；
        * `React` 目前的做法是使用链表，每个 `VirtualDOM` 节点内部表示为一个 Fiber；
        * 从顶点开始遍历；
        * 深度优先遍历；
        * ![流程图](images/WX20210514-112003.png)





## React 的生命周期函数

挂载
1. 调用 `ReactDOM.render`；
2. 进入 `Render 阶段`；
3. 采用 `深度优先遍历` 创建 `fiber 树`；
4. 进入 `Commit 阶段`；


更新
1. 调用 `this.setState`；
2. 进入 `Render 阶段`；
3. 采用 `深度优先遍历` 创建 `fiber 树`；
4. `reconcile 算法` 标记变化；
5. 进入 `Commit 阶段`；
6. 执行 `4` 中 `变化` 对应的 `视图操作`；
