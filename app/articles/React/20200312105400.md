
# 深入理解 React


## Virtual DOM 的理解

- 优点：
    + 处理了浏览器的兼容性问题，避免用户操作真实 DOM；
    + 内容进过了 XSS 处理，可以防范 XSS 攻击；
    + 容易实现跨平台开发 Android、iOS、VR 应用；
    + 更新的时候可以实现差异化更新，减少更新 DOM 的操作；
- 缺点：
    + 虚拟 DOM 需要消耗额外的内存；
    + 首次渲染其实并不一定会更快；



## 函数组件和类组件的相同点和不同点

- 相同点
    + 都可以接收属性并返回 React 元素；
- 不同点
    + 编程思想不同：类组件需要创建实例，是基于面向对象的方式编程。而函数式组件不需要创建实例，接收输入，返回输出，是基于
函数式编程的思想写的；
    + 内存占用：类组件需要创建并保存实例，会占用一定内存，函数组件不需要创建实例，可以节约内存占用；
    + 捕获特性：函数组件具有值捕获的特性；
    + 可测试性：函数式组件更方便编写单元测试；
    + 状态：类组件有自己的实例，可以定义状态，而且可以修改状态更新组件，函数式组件以前没有状态，现在可以使用 `useState` 使用状态；
    + 生命周期：类组件有自己完整的生命周期，可以在生命周期内编写逻辑，函数组件以前没有生命周期，现在可以使用 `useEffect` 实现类似生命周期的逻辑；
    + 逻辑复用：类组件可以通过继承实现逻辑复用，但是官方推荐组件优于继承，函数组件可以通过自定义 `Hooks` 实现逻辑的复用；
    + 跳过更新：类组件可以通过 `shouldComponentUpdate` 和 `PureComponent` 来跳过更新，而函数式组件可以使用 `React.momo` 来跳过更新；
    + 发展前景：函数组件会成为主流，它可以更好的屏蔽 `this` 问题、规范和复用逻辑、更好的适合时间分片和并发渲染；



## React 中的渲染流程

- 设计理念；
    + 跨平台渲染、虚拟 DOM；
    + 快速响应、异步可以中断 + 增量更新；
- 性能瓶颈；
    + 浏览器的刷新频率为60Hz，大概是16.6毫秒会渲染一次，而 JS 线程和渲染线程是互斥的，所以如果 JS 线程执行任务的时间超过
16.6毫秒的话，就会导致掉帧，从而出现卡顿。解决的方案就是 React 利用空闲的时间进行更新，不影响渲染进行的；
    + 把一个耗时任务切分成一个个小任务，分布在每一帧里面的方式就叫时间切片；
- `requestIdleCallback`，`chrome` 支持；
    + 它使开发者能在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应；
    + 正常帧任务完成后没超过16毫秒，说明时间有富余，此时会执行 `requestIdleCallback` 里面注册的任务；
- `react` 为了兼容性，使用了 `MessageChannel` + `requestAnimationFrame` 模拟了一个 `requestIdleCallback`；
- 写法：
```
// 同步
ReactDOM.render(<App/>, document.getElementById('root'));
// 异步可中断
ReactDOM.unstable_createRoot(document.getElementById('root')).render(<App/>); // 实验版本才会有这个 api
```
- **注** `react` 为了兼容这种异步操作，所以把 `componentWillMount` 、 `componentWillUpdate` 、 `componentWillReceiveProps` 废弃掉了；
- `fiber` 
    + 是一个执行单元；
        * 每次执行完一个执行单元，`React` 就会检查现在还剩多少时间，如果没有时间就将控制权让出去；
        * ![流程图](images/WX20210514-105509.png)
    + 是一种数据结构；
        * `React` 目前的做法是使用链表，每个 `VirtualDOM` 节点内部表示为一个 Fiber；
        * 从顶点开始遍历；
        * 深度优先遍历；
        * ![流程图](images/WX20210514-112003.png)
    + `fiber` 解决执行栈不能中断的问题；
- `Vue` 把每个更新任务分割的足够小， `watch` 组件级更新。 `React` 任务还是很大，但是分割成多个小任务，
可以中断和恢复，不阻塞主进程；





## React 的生命周期函数

挂载
1. 调用 `ReactDOM.render`；
2. 进入 `Render 阶段`:
    - 根据虚拟 DOM 生成 `fiber` 树；
    - 收集 `effectlist`；
3. 采用 `深度优先遍历` 创建 `fiber 树`；
4. 进入 `Commit 阶段`，进行 DOM 更新创建阶段，此阶段不能暂停，要一气呵成；


更新
1. 调用 `this.setState`；
2. 进入 `Reconciliation`(`协调/Render 阶段`)：可以认为是 `Diff` 阶段，这个阶段可以被中断，这个阶段
会找出所有节点的变更，例如节点新增、删除、属性变更等等，这些变更 `React` 称之为副作用 `Effect`；
3. 采用 `深度优先遍历` 创建 `fiber 树`：
    — 先儿子，后弟弟，再叔叔；
    - 自己所有子节点完成后自己完成；
4. `reconcile 算法` 标记变化；
5. 进入 `Commit 阶段`：将上一个阶段计算出来需要处理的副作用 `Effect` 一次性执行了，这个阶段必须同步执行，不能被打断；
6. 执行 `4` 中 `变化` 对应的 `视图操作`；



## React 中 DOM-DIFF 算法

在 `React17+` 中 `DOM-DIFF` 就是根据老的 `fiber` 树和最新的JSX对比生成新的 `fiber` 树的过程。

- 只对同级节点进行对比，如果 DOM 节点跨层级移动，则 React 不会复用；
- 不同类型的元素会产出不同的结构，会销毁老结构，创建新结构；
- 可以通过 key 标识移动的元素；

单节点流程
![流程图](images/WX20210517-104731.png)


多节点流程
- 多节点的时候会经历两轮遍历；
- 第一轮遍历主要是处理节点的更新，包括属性、和类型的更新；
- 第二轮遍历主要处理节点的新增、删除和移动；
- 移动的原则是尽量少量的移动，如果必须有一个要动，新地位高的不动，新地位低的动；



## React 合成事件

![事件流程机制](images/WX20210517-112723.png)

React 16
- `React` 把事件委托到 `document` 对象上；
- 当真实 DOM 元素触发事件，先处理原生事件，然后会冒泡到 `document` 对象后，再处理 `React` 事件；
- `React` 事件绑定的时刻是在 `reconciliation` 阶段，会在原生事件的绑定前执行；
- 目的和优势：
    + 浏览器兼容，React 采用的是顶层事件代理机制，能够保证冒泡的一致性；
    + 事件对象可能会被频繁创建和回收，因此 React 引入事件池，在事件池中获取或释放事件对象（React17中被废弃）；


React 17
- 事件委托的不再是 `document`，而是挂载的容器了，可以让一个页面使用多个 `react` 版本；
