
# Typescript 基础

> [官网](https://www.typescriptlang.org/)
> [中文官网](https://www.tslang.cn/)

TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对ES6的支持，它由
Microsoft 开发。


## 快速入门

安装依赖

```
npm install typescript -g

// 查看版本
tsc -v
```

编译 `ts` 文件

```
tsc test.ts // 目录下生成 test.js
```

监视文件变动，自动编译

```
tsc --watch test.ts
```

`WebStorm` 中配置自动编译 ts

1. 项目根目录下创建 `tsconfig.json` 
    - 可以执行 `ts --init` 创建；
    - 也可以直接创建；
```
{
    "compilerOptions": {
        "module": "commonjs",
        "target": "es5",
        "outDir": "./",
        "sourceMap": true
    },
    "exclude": [
        "node_modules"
    ]
}
```
2. 第二步，执行如下配置
![步骤二](images/WX20201119-135945@2x.png)
3. 第二步，执行如下配置
![步骤二](images/WX20201119-140059@2x.png)
完成上述步骤，即可自动编译ts。



## 基本数据类型


类型声明
- 通过类型声明可以指定 TS 中变量（参数、形参）的类型；
- 指定类型后，当为变量赋值时，TS 编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；
- 语法：
```
let 变量: 类型 = 值;
function fn (参数:类型, 参数:类型) : 类型 {
    ...
}
```
- 自动类型判断，TS 拥有自动的类型判断机制，当对变量的声明和赋值是同时进行的，TS 编译器会自动判断变量的类型。
所以如果变量的声明和赋值是同时进行的，可以省略类型声明；
- 声明变量如果不指定类型，则 TS 解析器会自动判断变量的类型为 `any` （隐式的 any）；
- 类型：
| 类型 | 例子 | 描述 |
| ---- | :----- | :---- |
| number | 1、 -2、 3.3 | 任意数字 |
| string | 'hi'、 "hi" | 任意字符串 |
| boolean | true、false | 布尔值 |
| 字面量 | 其本身 | 限制变量的值就是该字面量的值 |
| any | * | 任意类型 |
| unknown | * | 类型安全的 any |
| void | 空值（undefined） | 没有值（或 undefined ） |
| never | 没有值 | 不能是任何值 |
| object | {} | 任意的 JS 对象 |
| array | [1,2,3] | 任意 JS 数组 |
| tuple | [4, 5] | 元组，TS 新增类型，固定长度的数组 |
| enum | enum{A,B} | 枚举，TS 中新增类型 |


也可以直接使用字面量进行类型声明
```
let a: 10;
a = 10; // ✓ 正确
a = 1; // ✗ 错误

let b: 'male' | 'female';
b = 'male'; // ✓ 正确
b = 'female'; // ✓ 正确
b = 'haha'; // ✗ 错误
```


### | 、 & 联合类型

可以使用 `|` 、`&` 来连接多个类型，可以称之为联合类型；
- `|` 或；
```
let c: boolean | string;
c = false; // ✓ 正确
c = '123'; // ✓ 正确
c = 0; // ✗ 错误
```
- `&` 与；
```
let a : { name: string } & { age: number };
a = { name: '张三', age: 12 }; // ✓ 正确
a = { age: 13 }; // ✗ 错误
```



### any 和 unknown 的区别

- `any`：
    + 它可以赋值给任意变量；
    + 在任意值上访问任何属性、任何方法都是允许的；
    + 如果定义的时候没有赋值，不管之后有没有赋值，都会推断成 `any` 类型；
```
let a: any = '1'; // ✓ 正确
a = 2; // ✓ 正确
let s: string = a; // ✓ 不报错
```
- `unknown` 实际上就是一个类型安全的 `any`， 它不可以赋值给其他变量（除了 `any`类型的变量）；
```
let a: unknown = 1; // ✓ 正确
a = '2'; // ✓ 正确
let b: string = a; // ✗ 错误
let c: any = a; // ✓ 正确
// 判断之后再赋值
let d: string;
if (typeof a === 'string') {
    d = a; // ✓ 正确
}
// 类型断言
let e: string = a as string; // ✓ 正确
let f: string = <string>a; // ✓ 正确
```


### void 和 nerver 的区别

- `void` 用来表示空，以函数为例，就表示没有返回值的函数；
```
function fn1 () : void {
    console.log('hello ts');
}
```
- `nerver` 表示永远不会返回结果；
```
function fn2 (): never {
    throw new Error('报错了');
}
function fn3 (): never {
    while(true){}
}
```


### object 表示一个 js 对象，{} 可以用来指定对象可以包含哪些属性

- 语法 `{属性名1: 属性值1, 属性名2: 属性值2, ...}`；
- 在属性名后面加个 `?` 表示属性式可选的；
- `[propName: any]: any` 表示任意类型的属性；
```
let a: object; // ✓ 正确
a = {}; // ✓ 正确
a = function () {} // ✓ 正确
let b: {name: string, age?: number };
b = { name: '张三' } // ✓ 正确
b = { age: 12 } // ✗ 错误
let c = { name: string, [propName: any]: any };
c = { name: '李四', age: 12, sex: '男' } // ✓ 正确
```


### Function 表示一个函数

- 语法 `(形参1:类型, 形参2:类型, ...) => 返回值类型`
```
let a: (x: number, y: number) => number;
a = (x: number, y: number): number => x+ y; // ✓ 正确
```


### array 数组定义

- 语法 `类型[]` or `Array<类型>`；
```
let a: string[];
a = ['a', 'b', 'c']; // ✓ 正确
a = [1, '2']; // ✗ 错误
let b: Array<string>;
b = ['a', 'b', 'c']; // ✓ 正确
```


### tuple 元组的定义

- `tuple` 元组就是固定长度的数组；
- 语法 `[类型, 类型]`；
```
let a: [string, string];
a = ['1', '2']; // ✓ 正确
a = ['1', '2', '3']; // ✗ 错误
```


### enum 枚举

- 
```
enum Gender {
    Male,
    Female,
}
let a : { name: string, gender: Gender };
a = { name: '张三', gender: Gender.Male };
```


### 类型的别名

- 语法 `type 名 = 类型`
```
type myType = 1 | 2 | 3;
let a = myType;
a = 1; // ✓ 正确
a = 4; // ✗ 错误
```







## 对象数据类型

### 接口

在 `TypeScript` 中，使用接口 `Interfaces` 来定义对象类型；

```
interface Person {
    name: string;
    age: number;
    sayName: () => void;
}

let tom: Person = {
    name: 'Tom',
    age: 12,
    sayName () {
        console.log(`my name is ${this.name}`);
    }
};
```

定义的变量比接口少、或者多了一些属性都是不允许的。

可以定义可选属性

```
interface Person {
    name: string;
    age: number;
    sayName?: () => void;
}

// ✓
let tom: Person = {
    name: 'Tom',
    age: 12,
};
```

定义任意属性

```
interface Person {
    name: string;
    age: number;
    sayName?: () => void;
    [propName:string]: any
}
```


### 数组

不管是赋值，还是插入都需要遵循定义的类型；

```
let list: number[] = [1, 2, 3];

// 数组泛型的写法
let list2: Array<number> = [1, 2, 3];
```

接口定义数组

```
interface NumberArray {
    [index:number]: number
}

let arr: NumberArray = [1, 2, 3, 4]
```


### 函数

函数是 `Javascript` 中的一等公民，常见有两种定义函数的方式
- 函数声明 `Function Declaration` ；
- 函数表达式 `Function Expression` ；

一个函数有输入和输出，要对其进行约束，在 `TypeScript` 中
```
function sum (x: number, y: number): number {
    return x + y;
}
```

**输入多余的或者少输入参数都是不被允许的**

```
sum(1, 2); // ✓
sum(1, 2, 3); // ✗
sum(1); // ✗
```


### 类型断言

- 联合类型可以断言为其中类型；
- 父类可以断言为子类；
- 任何类型都可以断言为 `any` 类型；
- `any` 类型可以断言为任意类型；

```
interface Cat {
    name: string;
    run(): void;
}

interface Fish {
    name: string;
    swim(): void;
}
```

声明

```
function isFish (animal: Cat | Fish) {
    if ((animal as Fish).swim) {
        return true;
    } else {
        return false;
    }
}
```


### 类型别名

```
type str = string;
let username: str = '张三';
```

一般用于联合别名

```
type stringNumber = string|number;

let user: stringNumber = 123; // ✓
let user: stringNumber = '张三'; // ✓
let user: stringNumber = false; // ✗
```

约束字符串的取值

```
type eventName = 'click'|'scroll'|'mousemove'

let event: eventName = 'click'; // ✓
let event: eventName = 'touch'; // ✗
```


### 枚举类型

```
enum Days { sun, mon, tue, wed, thu, fri, sat }

console.log(Days['sun']); // 0
console.log(Days[0]); // sun

let day: Days = Days.sun;
let days: Days[] = [Days.sun, Days.mon]
```


## 类

`TypeScript` 中新增了三种访问修饰符

1. `public` ：修饰的属性或方法是公有的，可以在任何地方被访问到，默认
所有的属性和方法都是 `public` 的；
2. `private` ：修饰的属性或方法是私有的，不能在声明它的类外部访问；
3. `protected` ：修饰的属性或方法是受保护的，它和 `private` 类似，区别是它
在子类中也是允许被访问的；

```
class Animal {
    public name;
    private age;
    protected sayHello;
}
```

`readonly` 只读属性关键字，只允许出现在属性声明或索引签名或构造函数中

```
class Animal {
    readonly name;
}
```


## 抽象类

`abstract` 用于定义抽象类和其中的抽象方法

```
abstract class Animal {
    public name;
    public constructor (name) {
        this.name = name;
    };
    public abstract sayHi();
}
```

抽象类是不允许被实例化的

```
let a = new Animal('Jack'); // ✗
```

抽象类中的方法必须被子类实现

```
class Cat extends Animal {
    public eat () {}
}

let cat = new Cat('Tom'); // ✗
```

## 泛型

泛型 `Generics` 是指在定义函数、接口或类的时候，不预先指定具体的类型，而在
使用的时候再指定类型的一种特性。

```
function createArray<T>(length: number, value: T): Array<T> {
    let result: T[] = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}
```


## 其他

[点我查询TypeScript库](https://www.typescriptlang.org/dt/search)

