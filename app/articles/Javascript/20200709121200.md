
# ES6 新特性 涵盖 ES6-ES11

**注意** 本文只会记录一些特别的新特性


## 变量声明

### let 

- 变量不能重复声明；
- 块级作用域；
    + es5只有全局、函数、eval（严格模式下）作用域；
    + es6之后新增了块级作用域；
- 不存在变量提升；
- 不影响作用域链；

### const

- 一般用来声明常量；
- 一定要赋初始值；
- 值不能修改；


## 箭头函数

- `this` 是静态的，`this` 始终指向函数声明时所在作用域下的 `this` 值；
```
window.name = 'hello window';
function getName () {
    console.log(this.name);
}
const getName2 = () => {
    console.log(this.name);
}
const obj = {
    name: 'hello obj',
}
getName.call(obj); // hello window
getName2.call(obj); // hello obj
```
- 不能作为构造函数实例化对象；
- 不能使用 `arguments` 变量；


## rest 参数

`ES6` 引入了 `rest` 参数，用于获取函数的实参，用来代替 `arguments`。

```
function date(...args) {
    console.log(args); // args 为数组
}
```


## Symbol

`ES6` 引入的一种新的原始数据类型 `Symbol`，表示独一无二的值。
它是 `Javascript` 的第七种数据类型，是一种类似于字符串的数据类型。

- `Symbol` 的值是唯一的，用来解决命名冲突的问题；
- `Symbol` 的值不能与其他数据进行运算 `+、-、*、/、>...`；
- `Symbol` 定义的对象属性不能使用 `for..in` 循环遍历，但是可以使用
`Reflect.ownKeys` 来获取对象的所有键名；

```
// 创建 Symbol
let s = Symbol();
console.log(s, typeof s); // Symbol() "symbol"

let s2 = Symbol('张三');
let s3 = Symbol('张三');
console.log(s2 === s3); // false

let s4 = Symbol.for('李四');
let s5 = Symbol.for('李四');
console.log(s4 === s5); // true
```


## 迭代器（Iterator）

`ES6` 创造了一种新的遍历命令 `for...of` 循环，`Iterator`接口主要供 `for...of` 消费；

原生具备 `iterator` 接口的数据（可用 for of 遍历）
- `Array`
- `Arguments`
- `Set`
- `Map`
- `String`
- `TypedArray`
- `NodeList`

工作原理
- 创建一个指针对象，指向当前数据结构的起始位置；
- 第一次调用对象的 `next` 方法，指针自动指向数据结构的第一个成员；
- 然后不断调用 `next` 方法，指针一直往后移动，直到指向最后一个成员；
- 每调用 `next` 方法返回一个包含 `value` 和 `done` 属性的对象；

实际应用，用于自定义遍历数据
```
const person = {
    name: '张三',
    hobit: [
        '美食',
        '旅游',
        '打球',
        '游戏',
    ],
    [Symbol.iterator] () {
        let index = 0;
        let _that = this;
        return {
            next () {
                const result = { value: _that.hobit[index], done: index >= _that.hobit.length  };
                index++;
                return result;
            }
        }
    }
}
for (let item of person) {
    console.log(item);
}
// 美食
// 旅游
// 打球
// 游戏
```


## 生成器函数

生成器函数是 `ES6` 提供的一种异步编程的解决方案，语法行为与传统函数完成不同。

```
function * gen(){
    yield console.log(1);
    yield console.log(2);
    yield console.log(3);
}
let iterator = gen();
console.log(iterator); // iterator 对象
iterator.next(); // 1
iterator.next(); // 2
iterator.next(); // 3
```

可以用 `for...of` 进行遍历
```
for(let item of gen()){
    console.log(item);
}
```

生成器函数参数
```
function * gen(arg) {
    console.log(arg);
    let one = yield 111;
    console.log(one);
    let two = yield 222;
    console.log(two);
    let three = yield 333;
    console.log(three);
}
let iterator = gen('AAA');
iterator.next(); // AAA
iterator.next('BBB'); // BBB
iterator.next('CCC'); // CCC
iterator.next('DDD'); // DDD
```


## Set

`ES6` 提供了新的数据结构 `Set` 集合。它类似于数组，但成员的值都是唯一的，
集合实现了 `iterator` 接口，所以可以使用 `扩展运算符` 和 `for...of...` 进行遍历。

集合的属性和方法
- `size` 返回集合的元素个数；
- `add` 增加一个新的元素，返回当前集合；
- `delete` 删除元素，返回 `boolean` 值；
- `has` 检测集合中是否包含某个元素，返回 `boolean` 值；

实际应用
```
let arr = [1,2,3,4,4,3,2,5,1,0];
let result = [...new Set(arr)]; // 去重之后的数组
```


## Map

`ES6` 提供了 `Map` 数据结构。它类似于对象，也是键值对的集合。但是
"健"的范围不限于字符串，各种类型的值（包括对象）都可以当作健。 `Map` 也实现了
`iterator` 接口，所以可以使用 `扩展运算符` 和 `for...of...` 进行遍历。

`Map` 的属性和方法
- `size` 返回 `Map` 的元素个数；
- `set` 增加一个新元素，返回当前 `Map`；
- `get` 返回健名对象的健值；
- `has` 检测 `Map` 中是否包含某个元素，返回 `boolean`值；
- `clear` 清空集合，返回 `undefined`；


## Class

```
class Phone {
    price = 100
    get price () {
        return this._price;
    }
    set price (v) {
        this._price = v;
    }
}
```

## 数值扩展

- `Number.EPSILON` 是 `Javascript` 表示的最小精度。
```
Number.EPSILON
// 2.220446049250313e-16
```
