
# Node.js 基础


> [官方网站](https://nodejs.org/zh-cn/)

> [中文官方网站](http://nodejs.cn/)


## Node.js 是什么

> Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.

Node.js 是一个 Javascript 运行时环境，简单点来讲就是 Node.js 可以解析和执行 Javascript 代码；
- 事件驱动
- 非阻塞 IO 模型（异步）
- 轻量和高效

跟浏览器的区别：
浏览器中的 Javascript
- EcmaScript
    - 基本的语法
    - if、var、function、Object、Array
    - ...
- BOM
- DOM

Node.js 中的 Javascript
- EcmaScript
- 没有 BOM、DOM
- 给 Javascript 提供了一些服务器级别的操作 API
    - 服务的读写
    - 网络服务、通讯
    - 文件读写
    - ...


## Node.js 能做什么

- 服务器后台
- 命令行工具
    - npm
    - git(c 语言)
    - ...

## Node.js 的核心模块

Node.js 提供了很多服务器器级别的 API，这些 API 绝大多数都被包装到一个具名的核销模块中了；例如：
- 操作文件的 `fs` 模块
- http 服务构建的 `http` 模块
- 路径操作 `path` 模块
- 操作系统 `os` 模块
- ...


## 模块化

Javascript 天生不支持模块化，但在 Node.js 的这个环境中对 Javascript 进行了特殊的模块化
支持。`CommonJS` 模块规范，在 Node.js 中的 Javascript 有一个重要的概念，模块系统：
- 模块作用域；
- 使用 `require` 方法来加载模块；
- 使用 `exports` 方法来导出模块；

在浏览器中也可以像在 Node 中进行模块化编程，但是需要一些三方库的支持：
- `require.js` ： `amd` 规范；
- `sea.js` ： `cmd` 规范；

无论是 `CommonJS` 、`AMD`、`CMD`、`UMD`、`EcmaScript 6 Modules` 官方规范，都是为了解决 `Javascript` 的
模块化问题；


### 加载 require

> require 是一个方法，是用来加载模块的

通常模块有以下几种：
- 具名的核心模块，例如 fs、http；
- 自己编写的文件模块，需要注意：
    - 相对路径必须加 ./，不能省略，否则会报错；
    - 可以省略后缀名；

require 方法有两个作用：
- 加载文件模块并执行里面的代码；
- 拿到被加载文件模块导出的接口对象；

```
// 加载 fs
const fs = require('fs');

// 加载自己的模块文件 test.js
require('./test');
```

加载规则:
- 已加载的模块，会优先从缓存加载，可以直接拿到提供的对象，但是不会重复执行代码；
```
// main.js
require('./a');
require('./b');
// a.js
require('./b');
console.log('a.js 被加载');
// b.js
console.log('b.js 被加载');
// 执行
node main.js
// 输出
// a.js 被加载
// b.js 被加载
```
- 判断模块标识
    + 核心模块；
    + 第三方模块；举例 `require('art-template');` 加载顺序规则：
        1. `node_modules/` 目录；
        2. `node_modules/art-template/` 目录；
        3. `node_modules/art-template/package.json` 文件，如果没有这个文件，会自动找该目录下的 `index.js`；
        4. `node_modules/art-template/package.json` 文件中的 `mian` 属性，如果没有这个属性，
        会自动找该目录下的 `index.js` 文件；
        **注意**：如果以上所有任何一个条件都不成了，则会进入上一级目录中的 `node_modules` 目录查找；
        如果上一级还没有，就继续往上一级查找，直到根目录还找不到，就报错 `Can not find module xxx` ；
    + 路径形式的文件模块；

### 导出 exports

> 在每个文件模块中都提供了一个对象： `exports`，默认是一个空对象

所以把需要被外部访问的成员挂载到这个 `exports` 上；

```
// test.js
let name = 'hello node.js';
exports.name = name;

// main.js
const test = require('./test');
test.name; // hello node.js
```

如果一个模块需要直接导出某个程序，就需要这样才能重新赋值
```
// test.js
exports = '小明'; // ✗ 错误，不会成功赋值
module.exports = '张三'; // ✓ 正确

// main.js
const test = require('./test');
test // 张三
```

### module

在 Node.js 中，每个模块内部都有一个自己的对象 `module` ，该 `module` 对象中，
有一个成员叫 `exports` ，类似这种：
```
let module = {
    exports: {}
}
let exports = module.exports;
```

所以可以这样提供模块：
```
exports.name = '张三';
// 等价于
module.exports.name = 张三;
```

验证 `exports` 和 `module.exports`：
```
console.log(exports === module.exports); // true
```

默认在代码的最后有一句：
```
return module.exports;
```


## Node.js 中的其他成员

- `__dirname` ：可以用来获取当前文件模块所属目录的绝对路径；
- `__filename` ：可以获取当前文件的绝对路径；

**注意**在文件操作路径中，相对路径设计的就是相对于执行 `node` 命令所处的路径，
使用相对路径是不可靠的。所以在进行文件操作的时候，尽量使用绝对路径。

```
path.join(__dirname, 'text.txt');
```

[参考链接](https://www.infoq.cn/article/nodejs-module-mechanism/)
