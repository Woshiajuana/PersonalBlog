
# TypeScript 基础


## TypeScript 静态类型

- 基础静态类型

    + `boolean` 布尔值

    + `number` 数值

    + `string` 字符串

    + `array` 数组

    + 元组

    + `enum` 枚举值

    + `any`

    + `void`

        * 表示没有任何类型

        * 可以赋值 `undefined` 和 `null`，注意 `tsconfig.json` 配置 `strictNullChecks: true` 这项，则不可以赋值 `null`。

    + `never`

        * 不存在的类型，是任何类型的子类型，可以赋值给任何类型。

        * 报错

        ```ts
        const errorFunc = (message: string): never => {
            throw new Error(message)
        }
        ```

        * 死循环

        ```ts
        const infiniteFunc = (): nerver => {
            while(true){}
        }
        ```

    + `object`

    + `null` 和 `undefined`

    + 类型断言

    ```ts
    const target: string | number = '123';
    (<string>target).length
    // or
    (target as string).length
    ```

- 对象静态类型

    + 对象类型

    + 数组类型

    + 类类型

    + 函数类型


## 接口

- 基本用法

```ts
interface UserInfo {
    name: string,
    age: number
}
```

- 可选属性

```ts
interface UserInfo {
    name: string,
    age: number,
    hobbys?: string[]
}
```

- 多余属性检查

- 绕开多余属性检查

    + 强转类型

    + 索引签名

    + 类型兼容性

- 只读属性

```ts
interface UserInfo {
    readonly name: string,
    age: number,
    hobbys?: string[]
}
```

- 定义数组

```ts
interface ArrInter {
    0: number
    readonly 1: string
}
const arr: ArrInter = [1, 'a']
```

- 函数类型

```ts
type AddFunc = (num1: number, num2: number) => number
const add: AddFunc = (n1, n2) => n1 + n2

```

- 索引类型

```ts
interface RoleDic {
    [id: number]: string
}
const role: RoleDic = {
    'a': '123'
}
// error
```

如果索引定义的是 `string` 类型，是允许索引赋值 `number` 类型的，会自动转成 `string` 类型

- 继承接口

```ts
interface P {
    color: string
}
interface C extends P {
    size: number
}
const c: C = {
    color: 'red',
    size: 10
}
```

- 混合类型接口

`3.1` 版本才支持

```ts
interface Counter {
    (): void
    count: number
}
const getCounter = (): Counter => {
    const c = () => { c.count++ }
    c.count = 0
    return c
}
```


## 函数

### 函数类型

- 为函数定义类型

- 完整的函数类型

- 使用接口定义函数类型

- 使用类型别名

### 参数

- 可选参数

- 默认参数

- 剩余参数

```ts
const fun = (arg1: number, ...args: number[]) => {}
```

### 重载

```ts
function fun(x: string): string[]
function fun(x: number): number[]
function fun(x: any): any {
    if (typeof x === 'string') {
        return x.split('')
    } else {
        return x.toString().split('').map((item) => Number(item))
    }
}
console.log(fun('abc')) // ['a', 'b', 'c']
console.log(fun(123)) // [1, 2, 3]
```


## 泛型

- 简单使用

```ts
const getArray = <T>(value: T, times: number = 5): T[] => {
    return new Array(times).fill(value)
}
getArray<string>('1')
```

- 泛型变量

- 泛型类型

- 泛型约束

```ts
interface GetArray<T extends number> {

}
```

- 在泛型约束中使用类型参数

```ts
const getProps = <T, K extends keyof T>(object: T, propName: K) => {
    return object[propName]
}
const obj = { a: 'a', b: 'b' }
getProps(obj, 'a') // a
getProps(obj, 'c') // error
```


## 类型注解和类型推断


**注意** 工作中使用问题

- 如果 `TS` 能够自动分析变量类型，我们就什么也不用做了

- 如果 `TS` 无法分析变量类型的话，我们就需要使用类型注解



## 类的访问类型

- `private` 只能在类的内部使用

- `protected` 只能在类的内部以及子类中使用

- `public` 类的内部和外部使用



## tsconfig.json

`tsc -init`

- `compilerOptions`

    + `removeComments` 去掉注释

    + `outFile` 输出成一个文件 注意 `module` 需设置成 `amd`

    + `rootDir` 开发根目录

    + `outDir` 编译根目录

    + `sourceMap` 开发 or 编译文件之间的对应关系

    + `noUnusedLocals`

    + `strict` 严格按照规范来写

        * `noImplicitAny` 允许你的注解类型 `any` 不用特意标明

        * `strictNullChecks` 不运行


- `exclude`

- `include` 可以写正则 会被exclude排除

- `files` 不会被 `exclude` 排除，`include` 可以写正则 会被exclude排除


## 命名空间


```ts
namespace Home {
    const username = '张三'
    export const age = 12
}
```


`parcel`
